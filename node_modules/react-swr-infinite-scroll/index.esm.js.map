{"version":3,"file":"index.esm.js","sources":["../src/components/InfiniteScroll/index.tsx"],"sourcesContent":["import React, { Ref, useEffect, useState } from 'react'\nimport type { SWRInfiniteResponse } from 'swr'\n\ntype Props<T> = {\n  swr: SWRInfiniteResponse<T>\n  children: React.ReactChild | ((item: T) => React.ReactNode)\n  loadingIndicator?: React.ReactNode\n  endingIndicator?: React.ReactNode\n  isReachingEnd: boolean | ((swr: SWRInfiniteResponse<T>) => boolean)\n  offset?: number\n}\n\nconst useIntersection = <T extends HTMLElement>(): [boolean, Ref<T>] => {\n  const [intersecting, setIntersecting] = useState<boolean>(false)\n  const [element, setElement] = useState<HTMLElement>()\n  useEffect(() => {\n    if (!element) return\n    const observer = new IntersectionObserver((entries) => {\n      setIntersecting(entries[0]?.isIntersecting)\n    })\n    observer.observe(element)\n    return () => observer.unobserve(element)\n  }, [element])\n  return [intersecting, (el) => el && setElement(el)]\n}\n\nconst InfiniteScroll = <T,>(props: Props<T>): React.ReactElement<Props<T>> => {\n  const {\n    swr,\n    swr: { setSize, data, isValidating },\n    children,\n    loadingIndicator,\n    endingIndicator,\n    isReachingEnd,\n    offset = 0,\n  } = props\n\n  const [intersecting, ref] = useIntersection<HTMLDivElement>()\n\n  const ending = typeof isReachingEnd === 'function' ? isReachingEnd(swr) : isReachingEnd\n\n  useEffect(() => {\n    if (intersecting && !isValidating && !ending) {\n      setSize((size) => size + 1)\n    }\n  }, [intersecting, isValidating, setSize, ending])\n\n  return (\n    <>\n      {typeof children === 'function' ? data?.map((item) => children(item)) : children}\n      <div style={{ position: 'relative' }}>\n        <div ref={ref} style={{ position: 'absolute', top: offset }}></div>\n        {ending ? endingIndicator : loadingIndicator}\n      </div>\n    </>\n  )\n}\n\nexport default InfiniteScroll\n"],"names":["props","swr","_a","setSize","data","isValidating","children","loadingIndicator","endingIndicator","isReachingEnd","_b","offset","_c","useState","intersecting","setIntersecting","element","setElement","useEffect","observer","IntersectionObserver","entries","isIntersecting","observe","unobserve","el","useIntersection","ref","ending","size","React","map","item","style","position","top"],"mappings":"kEA0BuB,SAAKA,GAExB,IAAAC,EAOED,MANFE,EAMEF,MANKG,YAASC,SAAMC,iBACtBC,EAKEN,WAJFO,EAIEP,mBAHFQ,EAGER,kBAFFS,EAEET,gBADFU,EACEV,SADFW,aAAS,IAGLC,EAzBgB,WAChB,IAAAV,EAAkCW,GAAkB,GAAnDC,OAAcC,OACfL,EAAwBG,IAAvBG,OAASC,OAShB,OARAC,GAAU,WACR,GAAKF,EAAL,CACA,IAAMG,EAAW,IAAIC,sBAAqB,SAACC,SACzCN,YAAgBM,EAAQ,yBAAIC,mBAG9B,OADAH,EAASI,QAAQP,GACV,WAAM,OAAAG,EAASK,UAAUR,OAC/B,CAACA,IACG,CAACF,EAAc,SAACW,GAAO,OAAAA,GAAMR,EAAWQ,KAcnBC,GAArBZ,OAAca,OAEfC,EAAkC,mBAAlBnB,EAA+BA,EAAcR,GAAOQ,EAQ1E,OANAS,GAAU,YACJJ,GAAiBT,GAAiBuB,GACpCzB,GAAQ,SAAC0B,GAAS,OAAAA,EAAO,OAE1B,CAACf,EAAcT,EAAcF,EAASyB,IAGvCE,gCACuB,mBAAbxB,EAA0BF,MAAAA,SAAAA,EAAM2B,KAAI,SAACC,GAAS,OAAA1B,EAAS0B,MAAS1B,EACxEwB,uBAAKG,MAAO,CAAEC,SAAU,aACtBJ,uBAAKH,IAAKA,EAAKM,MAAO,CAAEC,SAAU,WAAYC,IAAKxB,KAClDiB,EAASpB,EAAkBD"}